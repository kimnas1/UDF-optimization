### Недочёты и «узкие места» исходной "F_WORKS_LIST"

1. **`F_WORKS_LIST` — многооператорная TVF**

   * Данные складываются во внутреннюю табличную переменную `@RESULT`, а у табличных переменных нет статистики.
   * Оптимизатор берёт консервативный план (Nested Loop), отключается параллелизм, идут чтения/записи в tempdb, row-estimate всегда «1».

2. **Два вызова `F_WORKITEMS_COUNT_BY_ID_WORK` на каждую строку**

   * Для выборки `TOP 3000` функций вызывается 6000 раз (по 0 / 1 в параметре `Is_Complit`).
   * 6000 сканов `WorkItem` даже при существующем индексе → всплески CPU и I/O.

3. **`F_WORKITEMS_COUNT_BY_ID_WORK`**

   * Фильтрация через `NOT IN (SELECT … WHERE is_group = 1)`.
   * Если подзапрос возвращает `NULL`, результат обнуляется; оптимизатор строит странный Anti Semi Join. Возможна логическая ошибка.

4. **`F_EMPLOYEE_FULLNAME` (вложенно вызывает `F_EMPLOYEE_GET`)**

   * Скалярные UDF + строковые конкатенации для каждой строки.
   * До SQL 2019 скалярная UDF делает план строго serial; дополнительный поиск в `Employee`.

5. **`ORDER BY Id_Work DESC` без перекрывающего индекса**

   * Кластерный PK по возрастанию ⇒ требуется явный Sort, дорогостоящий на больших выборках.

6. **Фильтр `Works.Is_Del <> 1`**

   * Неравенство по BIT-полю; SEEK не используется — лишний Table Scan всей `Works`.

7. **Отсутствие узких индексов**

   * Нет `(Id_Work, Is_Complit)` на `WorkItem` и `(CREATE_Date DESC, Id_Employee)` на `Works`.
   * Каждое из двух `COUNT(*)` делает кучу Lookup’ов; сортировка выполняется вручную.

8. **Нет покрытия `Price` в индексе**

   * Любая будущая агрегация цены потребует дополнительный кластерный Look-up → лишние дисковые обращения.

9. **CASE-логика для флага печати (`Is_Print`)**

   * Пять отдельных проверок дат в каждой строке — лишний CPU-кост; проще вынести в persisted-столбец.

10. **Потенциал блокировок**

    * 6000 отдельных селектов по `WorkItem` → столько же S-блокировок на страницах/ключах; при параллельных нагрузках растут wait’ы CXPACKET / SCH\_S.

