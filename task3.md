# Task 3 — Структурные изменения схемы БД

---

## Постановка задачи 3-го уровня

**Модель:** OpenAI o3  
**Контекст:** Исходный запрос уже ускорен до ~0,03 сек (Task 2)

**Промпт:**

> Исходный запрос уже ускорён: мы переписали `F_WORKS_LIST` во встроенную TVF и добавили два индекса.  
> Теперь требуются _структурные_ предложения — то есть изменения схемы (новые столбцы, триггеры, представления, партиции, сводные таблицы, широкие индексы).  
> Для каждого варианта нужно коротко указать:
> 
> * что именно добавляется или переделывается;  
> * какую выгоду это даёт: меньше чтений, исчезает `APPLY`, быстрее `TOP N`;  
> * какие побочные эффекты появляются — write-amplification, лишний объём, риск «неактуальных» данных, более сложные бэкапы, Enterprise-функции, админ-нагрузка и т. д.


## Предлагаемые изменения модели

### 1. Денормализованные счётчики в `Works`

**Что добавляется:** Два поля `ItemsTodo` и `ItemsDone`; AFTER-триггер на `WorkItem` обновляет их при любом изменении.

**Выгода:** Убирает две агрегации `COUNT(*)` — выборка трёх тысяч заказов выполняется за считаные миллисекунды.

**Побочные эффекты:** Каждое добавление или правка строки `WorkItem` порождает дополнительный UPDATE родительского заказа; вырастает конкуренция за строку и возникает риск рассинхрона, если кто-то загрузит данные bulk-режимом, отключив триггеры.


### 2. Persisted-колонка `Is_Print_Persisted`

**Что добавляется:** Логика «печать была» оформляется как вычисляемый столбец `PERSISTED` — запрос больше не проверяет пять полей `IS NULL`; колонку можно индексировать.

**Выгода:** Исчезает сложная CASE-логика из запроса, колонка доступна для индексирования.

**Побочные эффекты:** Лишний байт в строке и дополнительная запись страницы при любом изменении даты печати.


### 3. Индексированное представление с готовым JOIN и агрегатами

**Что добавляется:** Создаём `VIEW … WITH SCHEMABINDING` и кластерный индекс; UI читает `SELECT TOP 3000` прямо из представления за 1–2 мс.

**Выгода:** Максимальная скорость чтения, все JOIN'ы и агрегации уже материализованы.

**Побочные эффекты:** Каждый INSERT/UPDATE/DELETE на базовых таблицах обязан обновить индекс представления; изменить схему позже можно только через `DROP VIEW`; в Standard Edition нужен хинт `NOEXPAND`.


### 4. Отдельная сводная таблица `WorksAgg`

**Что добавляется:** Заполняется nightly ETL или Service Broker.

**Выгода:** Чтения идут из компактной витрины, не касаясь OLTP-таблиц.

**Побочные эффекты:** Отчёты могут отставать от оперативных данных; резервное восстановление осложняется, потому что нужно держать в согласии две таблицы.


### 5. Партиционирование `WorkItem` по дате создания

**Что добавляется:** Разбиение таблицы на секции по временным интервалам.

**Выгода:** Аналитика за нужный период читает лишь пару партиций; старые секции можно сжать или отключить.

**Побочные эффекты:** Enterprise-функция, регулярное обслуживание границ, возможные ошибки при вставке «не в ту» дату.



### 6. Широкие covering-индексы (с `INCLUDE`)

**Что добавляется:** Расширенные индексы с дополнительными столбцами в секции INCLUDE.

**Выгода:** Убирают bookmark lookup и экономят CPU.

**Побочные эффекты:** Увеличивают размер Б-дерева, делают массовые UPDATE/DELETE тяжелее и быстрее фрагментируются.


## Рекомендации по применению

**Для систем с преобладанием чтения:** Стоит принять счётчики и persisted-флаг — выигрыш заметный, побочный I/O мал.

**Для нагруженного OLTP:** Где каждую минуту вставляются тысячи `WorkItem`, лучше остаться на улучшениях уровня 2: триггеры и дополнительные поля здесь принесут больше вреда.

**Для тяжёлой аналитики:** На исторические данные оправданы индексированное представление или партиционирование.

**Важно:** Любой выбранный подход должен сопровождаться скриптами миграции и отката, учётом в резервных копиях и процедурами проверки согласованности.
